<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Pod::Advent 0.20 (Pod::Simple 3.07, Perl::Tidy 20090616) on 2010-12-01 02:29:44 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>2010 Perl Advent Calendar: Tangled Tidings</title>
<link rel="stylesheet" href="../style.css" type="text/css" />
<link rel="alternate" type="text/plain" href="mod1.pod" />
</head>
<body>
<h1><a href="../">Perl Advent Calendar 2010-12</a>-01</h1>
<h2 align="center">Tangled Tidings</h2>
<h3 align="center">by Jerrad Pierce</h3>
<p>We begin this year's calendar with a tool to help the adept Perl hacker cope with laziness, be it the laziness of selves past or someone else. <tt><a href="http://search.cpan.org/perldoc?YAPE::Regex::Explain">YAPE::Regex::Explain</a></tt> is a package in the <acronym title="Yet Another Parser/Extractor"><tt>YAPE&#8203;</tt></acronym> family which can untangle the Christmas lights of Perl&hellip; regular expressions. <tt>YAPEREE&#8203;</tt> turns line noise into English explanations. The unstyled output from:</p>
<pre><span class="c">% perl -MYAPE::Regex::Explain -e 'print YAPE::Regex::Explain-&gt;new(qr%&lt;([^\s&gt;]+)(?:\s+[^&gt;]*?)?(?:/|&gt;.*?&lt;/\1)&gt;%)-&gt;explain'</span></pre>
<p>looks like the following:</p>
<pre><span class="c">The regular expression:

(?s-imx:&lt;([^\s&gt;]+)(?:\s+[^&gt;]*?)?(?:/|&gt;.*?&lt;/\1)&gt;)

matches as follows:

NODE                     EXPLANATION
----------------------------------------------------------------------
(?s-imx:                 group, but do not capture (with . matching
                         \n) (case-sensitive) (with ^ and $ matching
                         normally) (matching whitespace and #
                         normally):
----------------------------------------------------------------------
  &lt;                        '&lt;'
----------------------------------------------------------------------
  (                        group and capture to \1:
----------------------------------------------------------------------
    [^\s&gt;]+                  any character except: whitespace (\n,
                             \r, \t, \f, and " "), '&gt;' (1 or more
                             times (matching the most amount
                             possible))
----------------------------------------------------------------------
  )                        end of \1
----------------------------------------------------------------------
  (?:                      group, but do not capture (optional
                           (matching the most amount possible)):
----------------------------------------------------------------------
    \s+                      whitespace (\n, \r, \t, \f, and " ") (1
                             or more times (matching the most amount
                             possible))
----------------------------------------------------------------------
    [^&gt;]*?                   any character except: '&gt;' (0 or more
                             times (matching the least amount
                             possible))
----------------------------------------------------------------------
  )?                       end of grouping
----------------------------------------------------------------------
  (?:                      group, but do not capture:
----------------------------------------------------------------------
    /                        '/'
----------------------------------------------------------------------
   |                        OR
----------------------------------------------------------------------
    &gt;                        '&gt;'
----------------------------------------------------------------------
    .*?                      any character (0 or more times (matching
                             the least amount possible))
----------------------------------------------------------------------
    &lt;/                       '&lt;/'
----------------------------------------------------------------------
    \1                       what was matched by capture \1
----------------------------------------------------------------------
  )                        end of grouping
----------------------------------------------------------------------
  &gt;                        '&gt;'
----------------------------------------------------------------------
)                        end of grouping
----------------------------------------------------------------------</span></pre>
<p>Pretty nifty, but arguably a somewhat redundant and unfortunate default given the more useful <span style="font-style: italic">regex</span> mode&mdash;no P!&mdash;which you can use to create a skeleton <tt><span class="q">/x</span></tt>-style commented regexp like the one <a href="#RE">at the end of this document</a>.</p>
<p>There's also a misleadingly named <span style="font-style: italic">silent</span> mode, which is a sort of regular expression pretty printer:</p>
<pre><span class="c">% perl -MYAPE::Regex::Explain -e 'print YAPE::Regex::Explain-&gt;new(qr%&lt;([^\s&gt;]+)(?:\s+[^&gt;]*?)?(?:/|&gt;.*?&lt;/\1)&gt;%g)-&gt;explain'

(?sx-im:

  &lt;

  (

    [^\s&gt;]+

  )

  (?x:

    \s+

    [^&gt;]*?

  )?

  (?x:

    /

   |

    &gt;

    .*?

    &lt;/

    \1

  )

  &gt;


)</span></pre>
<p>Although the POD notes that the module can parse some expressions passed as strings, this can fail, so you are better off passing everything through <tt><span class="q">qr//</span></tt> first. Perhaps the largest drawback to the current version of the module, for those who can read it's English output at least, is that it does not include support for syntax added since 5.6 e.g;</p>
<p><ul> <li>Named captures&mdash;<tt>(?&lt;yada&gt;&hellip;)</tt>&mdash;instead of counting parentheses</li> <li><a href="../../2005/13/">Regexp::Keep</a>&mdash;<tt>\K&hellip;</tt>&mdash;which is now core</li> <li>Recursive patterns&mdash;<tt>(?&#8470;&hellip;)</tt>&mdash;like back references, but for the pattern rather than the match; both might benefit from having the relevant pattern included in the explanatory comments instead of a simple <tt>\&#8470;</tt> </li> </ul></p>
<p>Thankfully, <tt>Explain</tt> is aware of the easily confused positive/negative look-ahead/behind e.g; <tt><a name="RE">/(?&lt;!foo)bar(?=quz)/</a></tt></p>
<pre>
<span class="s">(</span><span class="q">?x-ims:               # group, but do not capture (disregarding</span>
<span class="q">                       # whitespace and comments) (case-sensitive)</span>
<span class="q">                       # (with ^ and $ matching normally) (with . not</span>
<span class="q">                       # matching \n):</span>

  <span class="q">  (?</span>&lt;!                 <span class="c"># look behind to see if there is not:</span>

      <span class="w">foo</span>                  <span class="c"># &#39;foo&#39;</span>

  <span class="s">)</span>                      <span class="c"># end of look-behind</span>

  <span class="w">bar</span>                    <span class="c"># &#39;bar&#39;</span>

  <span class="s">(</span><span class="q">?=                    # look ahead to see if there is:</span>

  <span class="q">    quz                  # &#39;quz&#39;</span>

  <span class="q">)                      # end of look-ahead</span>


<span class="q">)                      # end of grouping</span>
</pre>

<a href="mod1.pl">More&raquo;</a>

<div style="float: right; font-size: 10pt"><a href="mod1.pod">View Source (POD)</a></div><br />
</body>
</html>
